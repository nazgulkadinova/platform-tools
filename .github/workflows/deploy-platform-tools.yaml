# This worflow is primarily for platform/devops tools that need to be deployed into K8s cluster
# or tools that don't belong to Terraform
name: "Workflow - Deploy Platform Tools"

on:
  push:
    branches:
      - feature/**
      - main

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: "us-east-1"
  ENVIRONMENT_STAGE: "dev"
 
  
  

jobs:
  deploy-platform-tools:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    environment: dev

    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.IAM_ROLE }}
          role-session-name: GitHubActionsRoleSession
          aws-region: ${{ env.AWS_REGION }}

      # Login to EKS, make sure to switch to the permanent cluster created with terraform once it's up
      - name: Login to EKS - update kubeconfig
        run: aws eks update-kubeconfig --name 23c-centos-eks-cluster --region $AWS_REGION

      # Add deployment steps for each tool below
      - name: Deploy ingress-nginx controller
        run: kubectl apply -f ingress-nginx/deploy.yaml

      # Example for a tool like Cluster Autoscaler
      - name: Deploy Cluster Autoscaler
        run: |
          echo "Deploy Cluster Autoscaler steps go here"

      # Example for a tool like EKS Logging
      - name: Deploy EKS Logging
        run: |
          echo "Deploy EKS Logging steps go here"
          KIBANA_CREDS_SECRET_NAME=Kibana_cred
          KIBANA_KEY_SECRET_NAME=Private-key-for-kibana-tls-cert
          SECRET_JSON=$(aws secretsmanager get-secret-value --region $AWS_REGION --secret-id $KIBANA_CREDS_SECRET_NAME --output json)
          PRIVATE_KEY=$(aws secretsmanager get-secret-value --secret-id $KIBANA_KEY_SECRET_NAME --output json | jq -r '.SecretString')
          PASSWORD=$(echo $SECRET_JSON | jq -r '.SecretString | fromjson | .Password')
          kubectl get ns efk || kubectl create ns efk
          kubectl get configmap fluentd-config -n efk || kubectl create configmap fluentd-config --from-literal=FLUENT_ELASTICSEARCH_PASSWORD="$PASSWORD" -n efk
          cd eks-logging/certs
          echo -n "$PRIVATE_KEY" > key.pem
          kubectl get secret kibana-tls-secret -n efk || kubectl create secret tls kibana-tls-secret --cert=cert.pem --key=key.pem -n efk
          cd ../helm-charts/elasticsearch/
          helm upgrade --install elasticsearch . --values ${ENVIRONMENT_STAGE}-values.yaml -n efk --set security.elasticPassword=$PASSWORD
          cd ../kibana
          helm upgrade --install kibana . --values ${ENVIRONMENT_STAGE}-values.yaml -n efk --set ingress.hostname=${ENVIRONMENT_STAGE}.kibana.312centos.com --set elasticsearch.security.auth.kibanaPassword=$PASSWORD
          cd ../..
          kubectl apply -f fluentd-configmap.yaml && kubectl apply -f fluentd-daemonset.yaml
          cd ..
          kubectl get all -n efk

      # Example for set up monitoring for Kubernetes cluster
      - name: Install Prometheus template
        run: |
            helm upgrade --install prometheus-release-dev ./eks-monitoring/helm-chart/prometheus/ \
             --values ./eks-monitoring/helm-chart/prometheus/values/prometheus-val-dev.yaml 

      # Create policy for Grafana
      - name: Check and Create IAM Policy
        run: |
          POLICY_NAME="grafana-access-policy"
          POLICY_ARN=$(aws iam list-policies --query "Policies[?PolicyName=='$POLICY_NAME'].Arn" --output text)

          if [ -z "$POLICY_ARN" ]; then
              echo "Policy does not exist, creating..."
              POLICY_DOCUMENT='{
                  "Version": "2012-10-17",
                  "Statement": [ {
                      "Effect": "Allow",
                      "Action": ["secretsmanager:GetSecretValue", "secretsmanager:DescribeSecret"],
                      "Resource": ["arn:aws:secretsmanager:us-east-1:036692858685:secret:dev/grafana/grafana-credentials-UAKfO7"]
                  } ]
              }'
              POLICY_ARN=$(aws iam create-policy --policy-name "$POLICY_NAME" --policy-document "$POLICY_DOCUMENT" --query "Policy.Arn" --output text)
              echo "Created policy ARN: $POLICY_ARN"
          else
              echo "Policy already exists with ARN: $POLICY_ARN"
          fi
          echo "POLICY_ARN=$POLICY_ARN" >> $GITHUB_ENV

      # Install eksctl
      - name: Install eksctl
        run: |
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin


      # Create role and serviceAccount for Grafana
      - name: Create role and sa for Grafana
        run: |
          eksctl create iamserviceaccount --name grafana-new-sa \
          --region=us-east-1 --cluster 23c-centos-eks-cluster \
          --namespace monitoring --approve \
          --attach-policy-arn "$POLICY_ARN" \
          --override-existing-serviceaccounts


      # Install grafana
      - name: Install grafana
        run: |
            helm upgrade --install grafana-release-dev ./eks-monitoring/helm-chart/grafana/ \
             --values ./eks-monitoring/helm-chart/grafana/values/grafana-val-dev.yaml -n monitoring

         
      
  
      # Repeat for each additional tool...
      # Example: Deploy External DNS
      
    
      # Example: Setup K8s User Roles
      - name: Setup K8s User Roles
        run: |
            echo "Deploy K8s user-roles go here"
      # Apply ServiceAccount, ClusterRole and ClusterRoleBindings   
      - name:  Apply ServiceAccount
        run: | 
            kubectl apply -f ./k8s-user-roles/service-account.yaml
      - name: Apply ClusterRole
        run: |
            kubectl apply -f ./k8s-user-roles/cluster-role.yaml
      - name: Apply ClusterRoleBinding
        run: |
            kubectl apply -f ./k8s-user-roles/cluster-role-binding.yaml
    
     
      - name: Finalize Deployment
        run: |
          echo "Final deployment steps and cleanup"